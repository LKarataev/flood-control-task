
# Flood control

Для тестирования решения с помощью **docker compose** введите команду:

`make`

Запустится окружение работающего приложения и хранилища **redis**. Само приложение запускается с аргументами `redis` - адрес хранилища, `limit` - колколичество вызовов (K), `interval` - количество секунд (N). При запуске через **docker compose** аргументы берутся из файла `.env`.

## Как пришёл к решению
  - Начал изучать как работает пакет **rate** (golang.org/x/time/rate), чтобы понять как выполнить задание.
  - В описании одного из блоков информации была ссылка на википедию про **алгоритм текущего ведра**.
  - Почитал и решил, что этот алгоритм в принципе может подойти и надо его реализовать.
  - В качестве хранилища рассматривал key/value хранилища **memcached** и **redis**.
  - Выбор остановил на **redis**: Все операции в нём атомарны, а значит команды, отправленные в рамках одной транзакции, выполняются последовательно, без вмешательства других операций. Даже если несколько экземпляров моего приложения попытаются одновременно выполнить функцию **Check** с одним и тем же **userID**, redis гарантирует, что каждая транзакция будет обработана поочередно. Что как раз необходимо для данного задания.
  - Реализовав алгоритм текущего ведра я понял, что он работает не совсем так, как нужно. В начале запуска пройденных проверок получается больше чем нужно из-за значения **burst**, хотя со временем проверки выходят на уровень, который соответствует задаче. Я понял, что **burst** мне вообще-то не нужен и можно сделать проще без него и так будет правильней.
  - Тогда я нашёл в интернете **алгоритм скользящего окна** (sliding window algorithm), который на мой взгляд лучше подходит для данной задачи.
  - Я его реализовал, протестировал и понял, что это то, что нужно.

## Краткое описание работы функции **Check**

При каждом вызове функция удаляет все запросы из **redis**, которые были сделаны ранее установленного интервала времени. Затем проверяет, сколько запросов было сделано (за последний интервал времени): если количество запросов не превышает установленный лимит, функция разрешает выполнение запроса и регистрирует его в **redis**. В противном случае — отклоняет его. В конце функции устанавливается время жизни ключа.
